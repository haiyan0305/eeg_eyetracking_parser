import numpy as np
import mne
import os
import getpass
import eeg_eyetracking_parser as eet
from mne_bids.copyfiles import copyfile_brainvision
from mne.preprocessing import ICA
import autoreject as ar
from shutil import copyfile
import json
import matplotlib.pyplot as plt


def rereference_channels(raw, ref_channels=['A1', 'A2']):
    """
    Rereference EEG data to the mastoids
    """
    raw.set_eeg_reference(ref_channels=ref_channels)
    raw.drop_channels(ref_channels)
    return raw


def drop_unused_channels(raw, chan_name_pattern='Channel'):
    """
    Drop unused channels. The pattern is that they all start with "Channel"
    """
    empty_chan_names = [chan_name for chan_name in raw.info['ch_names'] if chan_name.startswith(chan_name_pattern)]
    raw.drop_channels(empty_chan_names)
    return raw


def create_eog_channels(raw, eog_channels=['VEOGT', 'VEOGB', 'HEOGL', 'HEOGR']):
    """
    Create EOG channels by subtracting corresponding channels
    (VEOG = VEOGB - VEOGT)
    (HEOG = HEOGL - HEOGR)
    """
    chinds = [raw.ch_names.index(ichannel) for ichannel in eog_channels]
    veog = raw._data[chinds[0], :] - raw._data[chinds[1], :]
    heog = raw._data[chinds[2], :] - raw._data[chinds[3], :]
    veog = veog[np.newaxis, :]
    heog = heog[np.newaxis, :]
    info = mne.create_info(['VEOG', 'HEOG'], raw.info['sfreq'], ['eog', 'eog'])
    neweog = mne.io.RawArray(np.r_[veog, heog], info)
    raw.add_channels([neweog], force_update_info=True)
    raw.set_channel_types(dict(HEOG='eog', VEOG='eog'))
    raw.drop_channels(eog_channels)
    return raw


def set_montage(raw, montage_name='standard_1020', plot=False):
    """
    Set Montage for EEG channel positions
    Here we use standard_1020 and thus electrode names and positions are according to international 10-20 system
    """
    montage = mne.channels.make_standard_montage(montage_name)
    if plot:
        montage.plot()
    if 'Digi' in raw.info['ch_names']:
        raw.set_channel_types({'Digi': 'stim'})
    raw.set_montage(montage, match_case=False)
    return raw


def notch_filter(raw, frequencies_remove=(50, 100, 150, 200)):
    """
    Removes power line noise generated by EEG system
    """
    raw.notch_filter(frequencies_remove)
    return raw


def band_pass_filter(raw, lf=0.1, hf=40, plot=False):
    # default band-pass filter of 0.1 and 40
    """
    High-pass and low-pass filter for EEG data (band-pass filter)
    High-pass removes slow drifts
    Low-pass removes the short-term fluctuations
    """
    raw_unfiltered = raw.copy()
    raw.filter(l_freq=lf, h_freq=hf, picks='all')
    if plot:
        for title, data in zip(['Unfiltered', 'Bandpass filtered'], [raw_unfiltered, raw]):
            fig = data.plot_psd(fmax=250)
            fig.suptitle(title)
    return raw


def downsample_data(raw, srate=256):
    """
    Downsample EEG data for computational efficacy
    """
    raw.resample(srate, npad="auto")
    return raw


def autodetect_bad_channels(raw, events, plot=False, output_file=False, eeg_scaling=20e-5):
    """
    Detect bad channels using ransac algorithm
    """
    raw.info['bads'] = []
    raw.pick_types(eeg=True)
    trial_events = eet.trial_trigger(events)
    median_duration = np.median(trial_events[1:, 0] - trial_events[:-1, 0]) * 1.5
    cue_epoch = mne.Epochs(raw, trial_events, tmin=0, baseline=None,
                           tmax=median_duration / 1000, preload=True)
    ransac = ar.Ransac()
    ransac = ransac.fit(cue_epoch)
    raw.info['bads'] = ransac.bad_chs_

    if plot or output_file:
        bad_dir = os.path.join(preprocessing_path, "Bad_channels")
        subject_bad_dir = os.path.join(bad_dir, 'subject_' + str(raw.info['subject_info']['id']))
        if not os.path.exists(subject_bad_dir):
            os.makedirs(subject_bad_dir)

        if plot:
            raw.plot(butterfly=True, bad_color='r', scalings=eeg_scaling)
            plt.savefig(os.path.join(subject_bad_dir, 'raw_with_bads_ransac.png'))
            plt.show()

            fg = plt.figure(figsize=(20, 5))
            plt.bar(range(len(raw.ch_names)), ransac.bad_log.mean(0))
            plt.xticks(range(len(raw.ch_names)), raw.ch_names)
            plt.tight_layout()
            plt.savefig(os.path.join(subject_bad_dir, 'ransac_scores.png'))
            plt.show()

        if output_file:
            bads_txt_file = os.path.join(subject_bad_dir, 'bads.txt')
            raw_bads_file = os.path.join(subject_bad_dir, 'raw_bads_eeg.fif')
            with open(bads_txt_file, 'w') as f:
                json.dump(raw.info['bads'], f)
            raw.save(raw_bads_file, overwrite=True)

    return raw, ransac


def run_ica(raw, lf=1, sel_components='all', ica_method='picard', n_iter=500, random_state_set=97, output_file=False):
    """
    Run ICA (independent component analysis)
    Here we use a robust and fast 'picard' method by default as a fast and robust algorithm
    """
    raw_ica = raw.copy().filter(l_freq=lf, h_freq=None)
    if sel_components == 'all':
        picks = mne.pick_types(raw.info, eeg=True)
        n_sel_components = len(picks)
    else:
        n_sel_components = sel_components
    ica = ICA(n_components=n_sel_components, method=ica_method, max_iter=n_iter, random_state=random_state_set)
    ica.fit(raw_ica)

    if output_file:
        ica_dir = os.path.join(preprocessing_path, "ICA")
        subject_ica_dir = os.path.join(ica_dir, 'subject_' + str(raw.info['subject_info']['id']))
        if not os.path.exists(subject_ica_dir):
            os.makedirs(subject_ica_dir)
        ica.save(os.path.join(subject_ica_dir, 'res_ica.fif'), overwrite=True)
    return raw, ica


def auto_select_ica(raw, ica, plot=False, output_file=False):
    """
    Select ICA components automatically by matching them to EOG channels
    """
    eog_indices, eog_scores = ica.find_bads_eog(raw)
    ica.exclude = eog_indices
    ica.apply(raw)

    if plot:
        ica_dir = os.path.join(preprocessing_path, "ICA")
        subject_ica_dir = os.path.join(ica_dir, 'subject_' + str(raw.info['subject_info']['id']))
        if not os.path.exists(subject_ica_dir):
            os.makedirs(subject_ica_dir)
        for ieog in eog_indices:
            ica.plot_properties(raw, picks=ieog)
            plt.savefig(os.path.join(subject_ica_dir, str(ieog) + 'ica_component_properties.png'))
            plt.show()

        ica.plot_sources(raw, show_scrollbars=False)
        plt.savefig(os.path.join(subject_ica_dir, 'latent_sources_raw.png'))
        plt.show()

        ica.plot_scores(eog_scores)
        plt.savefig(os.path.join(subject_ica_dir, 'ica_scores.png'))
        plt.show()

    if output_file:
        ica_txt_file = os.path.join(subject_ica_dir, 'ica_removed.txt')
        ica_components = ['ICA component ' + str(x) for x in eog_indices]
        with open(ica_txt_file, 'w') as f:
            json.dump(ica_components, f)
    return raw

def interpolate_bads(raw, resetting=False):
    """
    Interpolate channels that we previously marked as bads
    """
    raw.interpolate_bads(reset_bads=resetting)
    return raw


if __name__ == '__main__':
    Username = getpass.getuser()
    EEG_path = os.path.join(os.path.sep, "Users", Username, "Documents", "Eyetracking_EEG")
    raw_data_folder = os.path.join(EEG_path, "raw_data")
    bids_data_folder = os.path.join(EEG_path, "data_bids")
    preprocessing_path = os.path.join(EEG_path, "preprocessing")
    if not os.path.exists(preprocessing_path):
        os.makedirs(preprocessing_path)
    subject_nr = 2

    create_bids_from_raw(raw_data_folder, bids_data_folder, subject_nr, 'pupman')
    raw, events, metadata = eet.read_subject(subject_nr, folder=bids_data_folder)
    raw.info['subject_info'] = {'id': subject_nr}

    rereference_channels(raw, ref_channels=['A1', 'A2'])
    drop_unused_channels(raw, chan_name_pattern='Channel')
    create_eog_channels(raw)
    set_montage(raw)  # plot=True

    band_pass_filter(raw)  # plot=True
    raw, ransac = autodetect_bad_channels(raw, events)  # plot=True, output_file=True
    # subject_bads_dir = os.path.join(preprocessing_path, "Bad_channels", 'subject_' + str(raw.info['subject_info']['id']))
    # raw = mne.io.read_raw_fif(os.path.join(subject_bads_dir, 'raw_bads_eeg.fif'))

    raw, ica = run_ica(raw, output_file=True)
    # subject_ica_dir = os.path.join(preprocessing_path, "ICA", 'subject_' + str(raw.info['subject_info']['id']))
    # ica = mne.preprocessing.read_ica(os.path.join(subject_ica_dir, 'res_ica.fif'))
    # raw = mne.io.read_raw_fif(os.path.join(subject_ica_dir, 'raw_ica_eeg.fif'))

    raw = auto_select_ica(raw, ica, plot=True, output_file=True)
    raw, AR = autoreject_artifacts(raw, output_file=True)
    raw = interpolate_bads(raw)


